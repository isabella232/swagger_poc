"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// identify the platform
// common locations
// check for minimums
// options (minimum version)
// 
// 
const request = require("request");
const fs_1 = require("fs");
const shell = require("shelljs");
const os_1 = require("os");
const path_1 = require("path");
const semver = require("semver");
const linq_es2015_1 = require("linq-es2015");
const utility_1 = require("./utility");
const github_1 = require("./github");
const tgz = require("tar.gz2");
const unzip = require("unzipper");
const console_1 = require("./console");
class Installer {
    static ensureExists(dir) {
        if (!fs_1.existsSync(dir)) {
            shell.mkdir("-p", dir);
        }
        return dir;
    }
    static GetFallbackUrl(url) {
        let newurl = url.replace("https://github.com/Azure/autorest/releases/download/", "https://autorest-releases.azureedge.net");
        if (newurl == url) {
            return null;
        }
        return newurl;
    }
    static get RootFolder() {
        return this.ensureExists(path_1.join(os_1.homedir(), '.autorest'));
    }
    static get FrameworkFolder() {
        return this.ensureExists(path_1.join(this.RootFolder, 'frameworks'));
    }
    static get PluginsFolder() {
        return path_1.join(this.RootFolder, 'plugins');
    }
    static get AutorestFolder() {
        return this.ensureExists(path_1.join(this.PluginsFolder, 'autorest'));
    }
    static get LatestAutorestVersion() {
        return this.InstalledAutorestVersions.FirstOrDefault();
    }
    static get InstalledAutorestVersions() {
        return this.GetVersionsInFolder(this.AutorestFolder) || linq_es2015_1.From([]);
    }
    static get InstalledFrameworkVersions() {
        return this.GetVersionsInFolder(`${this.FrameworkFolder}/shared/Microsoft.NETCore.App`) || linq_es2015_1.From([]);
    }
    static get LatestFrameworkVersion() {
        return this.InstalledFrameworkVersions.FirstOrDefault();
    }
    static get dotnet() {
        return "";
    }
    static HttpGet(url, filename, targetFolder, resolve, reject) {
        let download = request.get(url, {
            strictSSL: true,
            headers: {
                'user-agent': 'autorest-installer',
                "Authorization": `token ${utility_1.Utility.Id}`
            }
        });
        let unpack = null;
        if (filename.endsWith('.zip')) {
            unpack = download.pipe(unzip.Extract({ path: targetFolder }));
        }
        else {
            unpack = download.pipe(tgz().createWriteStream(targetFolder));
        }
        unpack.on('end', () => {
            setTimeout(resolve, 100);
        });
        unpack.on('error', () => {
            let newUrl = this.GetFallbackUrl(url);
            if (newUrl == null) {
                console_1.Console.Error(`Failed to download file: ${filename}`);
                return reject();
            }
            console_1.Console.Error(`Failed to download file: ${filename}, trying fallback url.`);
            this.HttpGet(newUrl, filename, targetFolder, resolve, reject);
        });
    }
    static InstallFramework() {
        return __awaiter(this, void 0, void 0, function* () {
            const pi = yield utility_1.Utility.PlatformInformation();
            const fwks = yield github_1.Github.GetAssets('dotnet-runtime-1.0.3');
            const runtime = fwks.FirstOrDefault(each => each.name.startsWith(`dotnet-${pi.runtimeId}.1.0.3`));
            if (runtime == null) {
                throw `Unable to find framework for ${pi.runtimeId}`;
            }
            return new Promise((resolve, reject) => {
                console_1.Console.Log(`Downloading __${runtime.browser_download_url}__ \n        to  __${this.FrameworkFolder}__`);
                this.HttpGet(runtime.browser_download_url, runtime.name, this.FrameworkFolder, resolve, reject);
            });
        });
    }
    static InstallAutoRest(version) {
        return __awaiter(this, void 0, void 0, function* () {
            const asset = (yield github_1.Github.GetAssets(`v${version}`)).FirstOrDefault();
            if (asset == null) {
                throw `Unable to find asset for version '${version}'`;
            }
            const targetFolder = path_1.join(this.AutorestFolder, version);
            return new Promise((resolve, reject) => {
                console_1.Console.Log(`Downloading __${asset.browser_download_url}__ \n        to  __${targetFolder}__`);
                this.HttpGet(asset.browser_download_url, asset.name, targetFolder, resolve, reject);
            });
        });
    }
    static GetVersionsInFolder(path) {
        return fs_1.existsSync(path) ? linq_es2015_1.From(shell.ls(path))
            .Select(each => semver.valid(each))
            .Where(each => each != null)
            .OrderBy(each => each, semver.rcompare) : linq_es2015_1.From([]);
    }
}
exports.Installer = Installer;
//# sourceMappingURL=installer.js.map